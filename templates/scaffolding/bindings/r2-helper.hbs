/**
 * {{HELPER_CLASS_NAME}} - R2 Bucket Helper
 *
 * Type-safe wrapper for Cloudflare R2 bucket: {{BINDING_NAME}}
 *
 * This helper provides convenient methods for working with R2 object storage,
 * including automatic JSON serialization, type safety, metadata handling, and streaming support.
 *
 * @example
 * ```typescript
 * const {{CAMEL_NAME}} = new {{HELPER_CLASS_NAME}}(env.{{BINDING_NAME}});
 *
 * // Upload a file
 * await {{CAMEL_NAME}}.put('uploads/document.pdf', pdfBuffer, {
 *   httpMetadata: { contentType: 'application/pdf' }
 * });
 *
 * // Download a file
 * const file = await {{CAMEL_NAME}}.get('uploads/document.pdf');
 * const buffer = await file?.arrayBuffer();
 *
 * // List files
 * const files = await {{CAMEL_NAME}}.list({ prefix: 'uploads/' });
 * ```
 */

/**
 * HTTP metadata for R2 objects
 */
export interface R2HttpMetadata {
	/**
	 * Content-Type header (e.g., 'image/jpeg', 'application/json')
	 */
	contentType?: string;

	/**
	 * Content-Encoding header (e.g., 'gzip', 'br')
	 */
	contentEncoding?: string;

	/**
	 * Content-Disposition header (e.g., 'attachment; filename="file.txt"')
	 */
	contentDisposition?: string;

	/**
	 * Content-Language header (e.g., 'en-US', 'fr-FR')
	 */
	contentLanguage?: string;

	/**
	 * Cache-Control header (e.g., 'public, max-age=3600')
	 */
	cacheControl?: string;
}

/**
 * Options for storing data in R2
 */
export interface R2PutOptions {
	/**
	 * HTTP metadata (content type, cache control, etc.)
	 */
	httpMetadata?: R2HttpMetadata;

	/**
	 * Custom metadata (user-defined key-value pairs, max 2KB)
	 * Useful for storing additional information about the object
	 */
	customMetadata?: Record<string, string>;

	/**
	 * MD5 hash for integrity checking
	 */
	md5?: ArrayBuffer | string;
}

/**
 * Options for listing objects
 */
export interface R2ListOptions {
	/**
	 * Only list objects with this prefix
	 */
	prefix?: string;

	/**
	 * Maximum number of objects to return (default: 1000, max: 1000)
	 */
	limit?: number;

	/**
	 * Pagination cursor from previous list operation
	 */
	cursor?: string;

	/**
	 * Delimiter for grouping objects (e.g., '/' for directory-style listing)
	 */
	delimiter?: string;

	/**
	 * Start listing after this key (exclusive)
	 */
	startAfter?: string;

	/**
	 * Include HTTP metadata in list results
	 */
	include?: ('httpMetadata' | 'customMetadata')[];
}

/**
 * R2 object metadata
 */
export interface R2ObjectMetadata {
	/**
	 * Object key
	 */
	key: string;

	/**
	 * Object size in bytes
	 */
	size: number;

	/**
	 * Upload timestamp
	 */
	uploaded: Date;

	/**
	 * ETag (entity tag)
	 */
	etag: string;

	/**
	 * HTTP metadata (if included in list)
	 */
	httpMetadata?: R2HttpMetadata;

	/**
	 * Custom metadata (if included in list)
	 */
	customMetadata?: Record<string, string>;
}

/**
 * Result of a list operation
 */
export interface R2ListResult {
	/**
	 * Array of objects matching the query
	 */
	objects: R2ObjectMetadata[];

	/**
	 * Whether there are more objects to fetch
	 */
	truncated: boolean;

	/**
	 * Cursor for fetching next page (if truncated is true)
	 */
	cursor?: string;

	/**
	 * Delimited prefixes (directory-like groupings)
	 */
	delimitedPrefixes: string[];
}

/**
 * Type-safe helper for {{BINDING_NAME}} R2 bucket
 */
export class {{HELPER_CLASS_NAME}} {
	constructor(private bucket: R2Bucket) {}

	/**
	 * Upload an object to R2
	 *
	 * @param key - The object key (path)
	 * @param value - The data to upload (string, ArrayBuffer, Blob, or ReadableStream)
	 * @param options - Upload options (HTTP metadata, custom metadata)
	 *
	 * @example
	 * ```typescript
	 * // Upload text
	 * await {{CAMEL_NAME}}.put('notes/memo.txt', 'Hello world', {
	 *   httpMetadata: { contentType: 'text/plain' }
	 * });
	 *
	 * // Upload with custom metadata
	 * await {{CAMEL_NAME}}.put('uploads/file.pdf', pdfBuffer, {
	 *   httpMetadata: { contentType: 'application/pdf' },
	 *   customMetadata: { userId: '123', uploadedBy: 'Alice' }
	 * });
	 * ```
	 */
	async put(
		key: string,
		value: string | ArrayBuffer | ArrayBufferView | ReadableStream | Blob,
		options: R2PutOptions = {},
	): Promise<R2Object | null> {
		return await this.bucket.put(key, value, options);
	}

	/**
	 * Upload text to R2
	 *
	 * @param key - The object key (path)
	 * @param text - The text to upload
	 * @param options - Upload options
	 *
	 * @example
	 * ```typescript
	 * await {{CAMEL_NAME}}.putText('notes/readme.txt', 'Welcome!', {
	 *   httpMetadata: { contentType: 'text/plain; charset=utf-8' }
	 * });
	 * ```
	 */
	async putText(
		key: string,
		text: string,
		options: R2PutOptions = {},
	): Promise<R2Object | null> {
		const mergedOptions: R2PutOptions = {
			...options,
			httpMetadata: {
				contentType: 'text/plain; charset=utf-8',
				...options.httpMetadata,
			},
		};
		return await this.bucket.put(key, text, mergedOptions);
	}

	/**
	 * Upload JSON to R2
	 *
	 * @param key - The object key (path)
	 * @param data - The data to serialize and upload
	 * @param options - Upload options
	 *
	 * @example
	 * ```typescript
	 * await {{CAMEL_NAME}}.putJSON('data/config.json', { theme: 'dark', language: 'en' });
	 * ```
	 */
	async putJSON<T = any>(
		key: string,
		data: T,
		options: R2PutOptions = {},
	): Promise<R2Object | null> {
		const mergedOptions: R2PutOptions = {
			...options,
			httpMetadata: {
				contentType: 'application/json; charset=utf-8',
				...options.httpMetadata,
			},
		};
		return await this.bucket.put(key, JSON.stringify(data), mergedOptions);
	}

	/**
	 * Download an object from R2
	 *
	 * @param key - The object key (path)
	 * @returns The object body and metadata, or null if not found
	 *
	 * @example
	 * ```typescript
	 * const file = await {{CAMEL_NAME}}.get('uploads/document.pdf');
	 * if (file) {
	 *   const buffer = await file.arrayBuffer();
	 *   console.log(`Downloaded ${file.size} bytes`);
	 * }
	 * ```
	 */
	async get(key: string): Promise<R2ObjectBody | null> {
		return await this.bucket.get(key);
	}

	/**
	 * Download an object as text
	 *
	 * @param key - The object key (path)
	 * @returns The object content as text, or null if not found
	 *
	 * @example
	 * ```typescript
	 * const readme = await {{CAMEL_NAME}}.getText('notes/readme.txt');
	 * console.log(readme);
	 * ```
	 */
	async getText(key: string): Promise<string | null> {
		const object = await this.bucket.get(key);
		return object ? await object.text() : null;
	}

	/**
	 * Download an object as JSON
	 *
	 * @param key - The object key (path)
	 * @returns The parsed JSON data, or null if not found
	 *
	 * @example
	 * ```typescript
	 * const config = await {{CAMEL_NAME}}.getJSON<Config>('data/config.json');
	 * if (config) {
	 *   console.log(config.theme);
	 * }
	 * ```
	 */
	async getJSON<T = any>(key: string): Promise<T | null> {
		const object = await this.bucket.get(key);
		return object ? await object.json<T>() : null;
	}

	/**
	 * Download an object as ArrayBuffer
	 *
	 * @param key - The object key (path)
	 * @returns The object content as ArrayBuffer, or null if not found
	 */
	async getArrayBuffer(key: string): Promise<ArrayBuffer | null> {
		const object = await this.bucket.get(key);
		return object ? await object.arrayBuffer() : null;
	}

	/**
	 * Download an object as Blob
	 *
	 * @param key - The object key (path)
	 * @returns The object content as Blob, or null if not found
	 */
	async getBlob(key: string): Promise<Blob | null> {
		const object = await this.bucket.get(key);
		return object ? await object.blob() : null;
	}

	/**
	 * Get object metadata without downloading the body
	 *
	 * @param key - The object key (path)
	 * @returns Object metadata, or null if not found
	 *
	 * @example
	 * ```typescript
	 * const meta = await {{CAMEL_NAME}}.head('uploads/large-file.zip');
	 * if (meta) {
	 *   console.log(`File size: ${meta.size} bytes`);
	 *   console.log(`Uploaded: ${meta.uploaded}`);
	 *   console.log(`Content-Type: ${meta.httpMetadata?.contentType}`);
	 * }
	 * ```
	 */
	async head(key: string): Promise<R2Object | null> {
		return await this.bucket.head(key);
	}

	/**
	 * Delete an object from R2
	 *
	 * @param key - The object key (path)
	 *
	 * @example
	 * ```typescript
	 * await {{CAMEL_NAME}}.delete('temp/cache.dat');
	 * ```
	 */
	async delete(key: string): Promise<void>;
	/**
	 * Delete multiple objects from R2
	 *
	 * @param keys - Array of object keys to delete
	 *
	 * @example
	 * ```typescript
	 * await {{CAMEL_NAME}}.delete(['temp/file1.txt', 'temp/file2.txt']);
	 * ```
	 */
	async delete(keys: string[]): Promise<void>;
	async delete(keyOrKeys: string | string[]): Promise<void> {
		await this.bucket.delete(keyOrKeys);
	}

	/**
	 * List objects in R2
	 *
	 * @param options - List options (prefix, limit, cursor, delimiter)
	 * @returns List of objects with pagination info
	 *
	 * @example
	 * ```typescript
	 * // List all objects with prefix
	 * const result = await {{CAMEL_NAME}}.list({ prefix: 'uploads/' });
	 * for (const obj of result.objects) {
	 *   console.log(`${obj.key}: ${obj.size} bytes`);
	 * }
	 *
	 * // Paginate through results
	 * let cursor: string | undefined;
	 * do {
	 *   const result = await {{CAMEL_NAME}}.list({ prefix: 'uploads/', cursor });
	 *   console.log(result.objects);
	 *   cursor = result.cursor;
	 * } while (result.truncated);
	 *
	 * // Directory-style listing
	 * const result = await {{CAMEL_NAME}}.list({
	 *   prefix: 'uploads/',
	 *   delimiter: '/'
	 * });
	 * console.log('Subdirectories:', result.delimitedPrefixes);
	 * ```
	 */
	async list(options: R2ListOptions = {}): Promise<R2ListResult> {
		const result = await this.bucket.list(options);
		return {
			objects: result.objects,
			truncated: result.truncated,
			...(result.truncated ? { cursor: result.cursor } : {}),
			delimitedPrefixes: result.delimitedPrefixes,
		};
	}

	/**
	 * Check if an object exists in R2
	 *
	 * @param key - The object key (path)
	 * @returns True if the object exists, false otherwise
	 *
	 * @example
	 * ```typescript
	 * if (await {{CAMEL_NAME}}.has('uploads/avatar.jpg')) {
	 *   console.log('Avatar exists');
	 * }
	 * ```
	 */
	async has(key: string): Promise<boolean> {
		const object = await this.bucket.head(key);
		return object !== null;
	}

	/**
	 * List all objects with a given prefix (fetches all pages)
	 *
	 * WARNING: This can be slow for large buckets as it fetches all pages.
	 * Consider using list() with pagination for better performance.
	 *
	 * @param prefix - Key prefix to filter by
	 * @returns Array of all matching objects
	 *
	 * @example
	 * ```typescript
	 * const allFiles = await {{CAMEL_NAME}}.listAll('uploads/user-123/');
	 * console.log(`Found ${allFiles.length} files`);
	 * ```
	 */
	async listAll(prefix?: string): Promise<R2ObjectMetadata[]> {
		const allObjects: R2ObjectMetadata[] = [];
		let cursor: string | undefined;

		do {
			const result = await this.list({ prefix, cursor });
			allObjects.push(...result.objects);
			cursor = result.cursor;
		} while (cursor);

		return allObjects;
	}

	/**
	 * Create a multipart upload for large files (>100 MB)
	 *
	 * Use this for uploading large files in chunks. Each part can be up to 5GB.
	 * You must upload at least 1 part and can upload up to 10,000 parts.
	 *
	 * @param key - The object key (path)
	 * @param options - Upload options (HTTP metadata, custom metadata)
	 * @returns Multipart upload object with uploadPart() and complete() methods
	 *
	 * @example
	 * ```typescript
	 * const upload = await {{CAMEL_NAME}}.createMultipartUpload('large-file.zip', {
	 *   httpMetadata: { contentType: 'application/zip' },
	 *   customMetadata: { uploadedBy: 'user-123' }
	 * });
	 *
	 * // Upload parts
	 * const part1 = await upload.uploadPart(1, chunk1);
	 * const part2 = await upload.uploadPart(2, chunk2);
	 *
	 * // Complete upload
	 * await upload.complete([part1, part2]);
	 * ```
	 */
	async createMultipartUpload(
		key: string,
		options?: R2PutOptions,
	): Promise<R2MultipartUpload> {
		return await this.bucket.createMultipartUpload(key, options);
	}
}
