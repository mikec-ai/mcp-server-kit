/**
 * {{HELPER_CLASS_NAME}} - D1 Database Helper
 *
 * Type-safe wrapper for Cloudflare D1 database: {{BINDING_NAME}} ({{DATABASE_NAME}})
 *
 * This helper provides convenient methods for SQL operations with D1,
 * including type safety, transaction support, and error handling.
 *
 * @example
 * ```typescript
 * const {{CAMEL_NAME}} = new {{HELPER_CLASS_NAME}}(env.{{BINDING_NAME}});
 *
 * // Query data
 * const users = await {{CAMEL_NAME}}.query<User>('SELECT * FROM users WHERE active = ?', [true]);
 *
 * // Insert data
 * await {{CAMEL_NAME}}.execute('INSERT INTO users (name, email) VALUES (?, ?)', ['Alice', 'alice@example.com']);
 *
 * // Batch operations
 * await {{CAMEL_NAME}}.batch([
 *   { sql: 'INSERT INTO users (name) VALUES (?)', params: ['Bob'] },
 *   { sql: 'INSERT INTO users (name) VALUES (?)', params: ['Carol'] }
 * ]);
 * ```
 */

/**
 * Result of a D1 query operation
 */
export interface D1QueryResult<T = any> {
	/**
	 * Whether the query succeeded
	 */
	success: boolean;

	/**
	 * Array of result rows
	 */
	results: T[];

	/**
	 * Metadata about the query execution
	 */
	meta: {
		/**
		 * Number of rows affected (for INSERT/UPDATE/DELETE)
		 */
		changes?: number;

		/**
		 * Last inserted row ID (for INSERT with AUTO_INCREMENT)
		 */
		last_row_id?: number;

		/**
		 * Query execution duration in milliseconds
		 */
		duration?: number;

		/**
		 * Number of rows returned
		 */
		rows_read?: number;

		/**
		 * Number of rows written
		 */
		rows_written?: number;
	};
}

/**
 * Statement for batch execution
 */
export interface D1Statement {
	/**
	 * SQL query string
	 */
	sql: string;

	/**
	 * Query parameters (optional)
	 */
	params?: any[];
}

/**
 * Type-safe helper for {{BINDING_NAME}} D1 database
 */
export class {{HELPER_CLASS_NAME}} {
	constructor(private db: D1Database) {}

	/**
	 * Execute a SQL query and return all results
	 *
	 * @param sql - SQL query string (use ? for parameters)
	 * @param params - Query parameters
	 * @returns Array of result rows
	 *
	 * @example
	 * ```typescript
	 * // Fetch all users
	 * const users = await {{CAMEL_NAME}}.query<User>('SELECT * FROM users');
	 *
	 * // Fetch with parameters
	 * const active = await {{CAMEL_NAME}}.query<User>(
	 *   'SELECT * FROM users WHERE active = ? AND role = ?',
	 *   [true, 'admin']
	 * );
	 * ```
	 */
	async query<T = any>(sql: string, params: any[] = []): Promise<T[]> {
		const stmt = this.db.prepare(sql);
		const bound = params.length > 0 ? stmt.bind(...params) : stmt;
		const result = await bound.all<T>();

		if (!result.success) {
			throw new Error(`D1 query failed: ${sql}`);
		}

		return result.results;
	}

	/**
	 * Execute a SQL query and return the first result
	 *
	 * @param sql - SQL query string (use ? for parameters)
	 * @param params - Query parameters
	 * @returns First result row, or null if no results
	 *
	 * @example
	 * ```typescript
	 * // Fetch single user by ID
	 * const user = await {{CAMEL_NAME}}.queryFirst<User>(
	 *   'SELECT * FROM users WHERE id = ?',
	 *   [userId]
	 * );
	 *
	 * if (user) {
	 *   console.log(user.name);
	 * }
	 * ```
	 */
	async queryFirst<T = any>(
		sql: string,
		params: any[] = [],
	): Promise<T | null> {
		const stmt = this.db.prepare(sql);
		const bound = params.length > 0 ? stmt.bind(...params) : stmt;
		const result = await bound.first<T>();

		return result;
	}

	/**
	 * Execute a SQL query and return raw result with metadata
	 *
	 * @param sql - SQL query string (use ? for parameters)
	 * @param params - Query parameters
	 * @returns Query result with metadata
	 *
	 * @example
	 * ```typescript
	 * const result = await {{CAMEL_NAME}}.queryRaw<User>(
	 *   'SELECT * FROM users WHERE active = ?',
	 *   [true]
	 * );
	 *
	 * console.log(`Found ${result.results.length} users`);
	 * console.log(`Query took ${result.meta.duration}ms`);
	 * ```
	 */
	async queryRaw<T = any>(
		sql: string,
		params: any[] = [],
	): Promise<D1QueryResult<T>> {
		const stmt = this.db.prepare(sql);
		const bound = params.length > 0 ? stmt.bind(...params) : stmt;
		const result = await bound.all<T>();

		if (!result.success) {
			throw new Error(`D1 query failed: ${sql}`);
		}

		return result;
	}

	/**
	 * Execute a SQL statement (INSERT, UPDATE, DELETE)
	 *
	 * @param sql - SQL statement string (use ? for parameters)
	 * @param params - Statement parameters
	 * @returns Result with metadata (changes, last_row_id)
	 *
	 * @example
	 * ```typescript
	 * // Insert new user
	 * const result = await {{CAMEL_NAME}}.execute(
	 *   'INSERT INTO users (name, email) VALUES (?, ?)',
	 *   ['Alice', 'alice@example.com']
	 * );
	 *
	 * console.log(`Inserted user with ID: ${result.meta.last_row_id}`);
	 *
	 * // Update user
	 * const updated = await {{CAMEL_NAME}}.execute(
	 *   'UPDATE users SET name = ? WHERE id = ?',
	 *   ['Alice Smith', 123]
	 * );
	 *
	 * console.log(`Updated ${updated.meta.changes} rows`);
	 *
	 * // Delete user
	 * await {{CAMEL_NAME}}.execute('DELETE FROM users WHERE id = ?', [123]);
	 * ```
	 */
	async execute(sql: string, params: any[] = []): Promise<D1QueryResult> {
		const stmt = this.db.prepare(sql);
		const bound = params.length > 0 ? stmt.bind(...params) : stmt;
		const result = await bound.run();

		if (!result.success) {
			throw new Error(`D1 execution failed: ${sql}`);
		}

		return result;
	}

	/**
	 * Execute multiple SQL statements in a batch
	 *
	 * Batching is more efficient than executing statements individually.
	 * All statements execute atomically (all succeed or all fail).
	 *
	 * @param statements - Array of SQL statements with parameters
	 * @returns Array of results for each statement
	 *
	 * @example
	 * ```typescript
	 * // Insert multiple users in one batch
	 * const results = await {{CAMEL_NAME}}.batch([
	 *   {
	 *     sql: 'INSERT INTO users (name, email) VALUES (?, ?)',
	 *     params: ['Alice', 'alice@example.com']
	 *   },
	 *   {
	 *     sql: 'INSERT INTO users (name, email) VALUES (?, ?)',
	 *     params: ['Bob', 'bob@example.com']
	 *   },
	 *   {
	 *     sql: 'INSERT INTO users (name, email) VALUES (?, ?)',
	 *     params: ['Carol', 'carol@example.com']
	 *   }
	 * ]);
	 *
	 * console.log(`Inserted ${results.length} users`);
	 * ```
	 */
	async batch(statements: D1Statement[]): Promise<D1QueryResult[]> {
		const preparedStatements = statements.map((stmt) => {
			const prepared = this.db.prepare(stmt.sql);
			return stmt.params && stmt.params.length > 0
				? prepared.bind(...stmt.params)
				: prepared;
		});

		const results = await this.db.batch(preparedStatements);

		// Check if any statement failed
		const failedIndex = results.findIndex((r) => !r.success);
		if (failedIndex !== -1) {
			throw new Error(
				`D1 batch execution failed at statement ${failedIndex}: ${statements[failedIndex].sql}`,
			);
		}

		return results;
	}

	/**
	 * Execute raw SQL without parameters
	 *
	 * WARNING: This bypasses parameter binding. Only use for trusted SQL.
	 * Prefer query() or execute() with parameters to prevent SQL injection.
	 *
	 * @param sql - Raw SQL string
	 * @returns Query result
	 *
	 * @example
	 * ```typescript
	 * // Create table (no parameters needed)
	 * await {{CAMEL_NAME}}.exec(`
	 *   CREATE TABLE IF NOT EXISTS users (
	 *     id INTEGER PRIMARY KEY AUTOINCREMENT,
	 *     name TEXT NOT NULL,
	 *     email TEXT UNIQUE NOT NULL,
	 *     created_at DATETIME DEFAULT CURRENT_TIMESTAMP
	 *   )
	 * `);
	 * ```
	 */
	async exec(sql: string): Promise<D1ExecResult> {
		try {
			return await this.db.exec(sql);
		} catch (error) {
			throw new Error(
				`D1 exec failed: ${sql}. Error: ${error instanceof Error ? error.message : String(error)}`,
			);
		}
	}

	/**
	 * Check if a table exists in the database
	 *
	 * @param tableName - Name of the table to check
	 * @returns True if table exists, false otherwise
	 *
	 * @example
	 * ```typescript
	 * if (await {{CAMEL_NAME}}.hasTable('users')) {
	 *   console.log('Users table exists');
	 * }
	 * ```
	 */
	async hasTable(tableName: string): Promise<boolean> {
		const result = await this.queryFirst<{ count: number }>(
			"SELECT COUNT(*) as count FROM sqlite_master WHERE type='table' AND name=?",
			[tableName],
		);

		return result ? result.count > 0 : false;
	}

	/**
	 * Get count of rows in a table
	 *
	 * @param tableName - Name of the table
	 * @param whereClause - Optional WHERE clause (without WHERE keyword)
	 * @param params - Parameters for WHERE clause
	 * @returns Number of rows
	 *
	 * @example
	 * ```typescript
	 * // Count all users
	 * const totalUsers = await {{CAMEL_NAME}}.count('users');
	 *
	 * // Count active users
	 * const activeUsers = await {{CAMEL_NAME}}.count('users', 'active = ?', [true]);
	 * ```
	 */
	async count(
		tableName: string,
		whereClause?: string,
		params: any[] = [],
	): Promise<number> {
		const sql = whereClause
			? `SELECT COUNT(*) as count FROM ${tableName} WHERE ${whereClause}`
			: `SELECT COUNT(*) as count FROM ${tableName}`;

		const result = await this.queryFirst<{ count: number }>(sql, params);

		return result ? result.count : 0;
	}

	/**
	 * Check if any rows match the given condition
	 *
	 * @param tableName - Name of the table
	 * @param whereClause - WHERE clause (without WHERE keyword)
	 * @param params - Parameters for WHERE clause
	 * @returns True if at least one row matches, false otherwise
	 *
	 * @example
	 * ```typescript
	 * const hasAdmin = await {{CAMEL_NAME}}.exists(
	 *   'users',
	 *   'role = ? AND active = ?',
	 *   ['admin', true]
	 * );
	 * ```
	 */
	async exists(
		tableName: string,
		whereClause: string,
		params: any[] = [],
	): Promise<boolean> {
		const count = await this.count(tableName, whereClause, params);
		return count > 0;
	}

	/**
	 * Insert a single row and return the inserted ID
	 *
	 * @param tableName - Name of the table
	 * @param data - Object with column names and values
	 * @returns Inserted row ID
	 *
	 * @example
	 * ```typescript
	 * const userId = await {{CAMEL_NAME}}.insert('users', {
	 *   name: 'Alice',
	 *   email: 'alice@example.com',
	 *   active: true
	 * });
	 *
	 * console.log(`Created user with ID: ${userId}`);
	 * ```
	 */
	async insert(tableName: string, data: Record<string, any>): Promise<number> {
		const columns = Object.keys(data);
		const values = Object.values(data);
		const placeholders = columns.map(() => '?').join(', ');

		const sql = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders})`;
		const result = await this.execute(sql, values);

		return result.meta.last_row_id || 0;
	}

	/**
	 * Update rows matching the WHERE clause
	 *
	 * @param tableName - Name of the table
	 * @param data - Object with column names and new values
	 * @param whereClause - WHERE clause (without WHERE keyword)
	 * @param whereParams - Parameters for WHERE clause
	 * @returns Number of rows updated
	 *
	 * @example
	 * ```typescript
	 * const updated = await {{CAMEL_NAME}}.update(
	 *   'users',
	 *   { name: 'Alice Smith', updated_at: new Date().toISOString() },
	 *   'id = ?',
	 *   [123]
	 * );
	 *
	 * console.log(`Updated ${updated} rows`);
	 * ```
	 */
	async update(
		tableName: string,
		data: Record<string, any>,
		whereClause: string,
		whereParams: any[] = [],
	): Promise<number> {
		const columns = Object.keys(data);
		const values = Object.values(data);
		const setClause = columns.map((col) => `${col} = ?`).join(', ');

		const sql = `UPDATE ${tableName} SET ${setClause} WHERE ${whereClause}`;
		const result = await this.execute(sql, [...values, ...whereParams]);

		return result.meta.changes || 0;
	}

	/**
	 * Delete rows matching the WHERE clause
	 *
	 * @param tableName - Name of the table
	 * @param whereClause - WHERE clause (without WHERE keyword)
	 * @param params - Parameters for WHERE clause
	 * @returns Number of rows deleted
	 *
	 * @example
	 * ```typescript
	 * const deleted = await {{CAMEL_NAME}}.deleteWhere(
	 *   'users',
	 *   'active = ? AND last_login < ?',
	 *   [false, '2020-01-01']
	 * );
	 *
	 * console.log(`Deleted ${deleted} inactive users`);
	 * ```
	 */
	async deleteWhere(
		tableName: string,
		whereClause: string,
		params: any[] = [],
	): Promise<number> {
		const sql = `DELETE FROM ${tableName} WHERE ${whereClause}`;
		const result = await this.execute(sql, params);

		return result.meta.changes || 0;
	}
}
